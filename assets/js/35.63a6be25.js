(window.webpackJsonp=window.webpackJsonp||[]).push([[35],{310:function(t,a,e){"use strict";e.r(a);var r=e(13),s=Object(r.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"_1、谈谈你对-react-的了解-必会"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1、谈谈你对-react-的了解-必会"}},[t._v("#")]),t._v(" 1、谈谈你对 React 的了解(必会)")]),t._v(" "),a("p",[t._v("React 是用于构建前端页面的 JavaScript 库。React 主要用于构建 UI，由 Facebook 于 2013 年开源。")]),t._v(" "),a("p",[t._v("React 特点:")]),t._v(" "),a("ol",[a("li",[t._v("声明式设计 −React 采用声明范式，可以轻松描述应用。")]),t._v(" "),a("li",[t._v("高效 −React 通过对     DOM 的模拟，最大限度地减少与 DOM 的交互。")]),t._v(" "),a("li",[t._v("灵活 −React 可以与已知的库或框架很好地配合。")]),t._v(" "),a("li",[t._v("JSX − JSX     是 JavaScript 扩展语法。React     开发不一定使用 JSX, 但我们建议使用它。")]),t._v(" "),a("li",[t._v("组件 − 通过     React 构建组件，代码更容易复用，能够很好的应用在大项目的开发中。")]),t._v(" "),a("li",[t._v("单向数据流 − React 实现了单向响应的数据流，从而减少了重复代码，这也是它为什么")])]),t._v(" "),a("p",[t._v("比传统数据绑定更简单。")]),t._v(" "),a("h2",{attrs:{id:"_2、什么是-jsx-为什么浏览器无法读取-jsx-必会"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2、什么是-jsx-为什么浏览器无法读取-jsx-必会"}},[t._v("#")]),t._v(" 2、什么是 JSX?为什么浏览器无法读取 JSX?(必会)")]),t._v(" "),a("p",[t._v("JSX 是 JavaScript XML 的简写，它利用 JavaScript 的表现力和类似 HTML 的模板语 法，得 HTML 文件非常容易理解。此文件能使应用非常可靠，并能够提高其性能。浏览器 只能处理 JavaScript 对象，而不能读取常规 JavaScript 对象中的 JSX，所以为了使浏览器 能够读取 JSX，首先，需要用 Babel 转换器将 JSX 文件转换为 JavaScript 对象，然后再将 其传给浏览器")]),t._v(" "),a("h2",{attrs:{id:"_3、shouldcomponentupdate-是做什么的-必会"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3、shouldcomponentupdate-是做什么的-必会"}},[t._v("#")]),t._v(" 3、shouldComponentUpdate 是做什么的?(必会)")]),t._v(" "),a("p",[t._v("shouldComponentUpdate 这个方法用来判断是否需要调用 render 方法重新绘制 dom，因 为 DOM 的描绘非常消耗性能，如果我们能在 shouldComponentUpdate 方法中能够写出更优 化的 dom diff 算法，可以极大的提高性能。")]),t._v(" "),a("h2",{attrs:{id:"_4、react-性能优化是哪个周期函数-必会"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4、react-性能优化是哪个周期函数-必会"}},[t._v("#")]),t._v(" 4、React 性能优化是哪个周期函数?(必会)")]),t._v(" "),a("p",[t._v("shouldComponentUpdate")]),t._v(" "),a("h2",{attrs:{id:"_5、react-中-keys-的作用是什么-必会"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5、react-中-keys-的作用是什么-必会"}},[t._v("#")]),t._v(" 5、React 中 keys 的作用是什么?(必会)")]),t._v(" "),a("p",[t._v("Keys 是 React 用于追踪哪些列表中元素被修改、被添加或者被移除的辅助标识。在开发过 程中，我们需要保证某个元素的 key 在其同级元素中具有唯一性。")]),t._v(" "),a("p",[t._v("在 React Diff 算法中 React 会借助元素的 Key 值来判断该元素是新近创建的还是被移动 而来的元素，从而减少不必要的元素重渲染;")]),t._v(" "),a("p",[t._v("此外，React 还需要借助 Key 值来判断元素与本地状态的关联关系，因此我们绝不可忽视 转换函数中 Key 的重要性。")]),t._v(" "),a("h2",{attrs:{id:"_6、react-中-refs-的作用是什么-必会"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6、react-中-refs-的作用是什么-必会"}},[t._v("#")]),t._v(" 6、React 中 refs 的作用是什么?(必会)")]),t._v(" "),a("p",[t._v("Refs 是 React 提供给我们的安全访问 DOM 元素或者某个组件实例的句柄，我们可以为元 素添加 ref 属性然后在回调函数中接受该元素在 DOM 树中的句柄，该值会作为回调函数的第 一个参数返回。")]),t._v(" "),a("h2",{attrs:{id:"_7、请列举-react-中定义组件的方法-必会"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_7、请列举-react-中定义组件的方法-必会"}},[t._v("#")]),t._v(" 7、请列举 React 中定义组件的方法?(必会)")]),t._v(" "),a("p",[t._v("\\1. 函数式定义的无状态组件\n\\2. es6 中 extends React.Component 定义的组件")]),t._v(" "),a("h2",{attrs:{id:"_8、调用-setstate-之后发生了什么-必会"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_8、调用-setstate-之后发生了什么-必会"}},[t._v("#")]),t._v(" 8、调用 setState 之后发生了什么?(必会)")]),t._v(" "),a("ol",[a("li",[t._v("代码中调用     setState 函数之后，React 会将传入的参数对象与组件当前的状态合并，然后触 发所谓的调和过程(Reconciliation)。")]),t._v(" "),a("li",[t._v("经过调和过程，React     会以相对高效的方式根据新的状态构建 React 元素树并且着手重新渲 染整个     UI 界面;")]),t._v(" "),a("li",[t._v("在 React 得到元素树之后，React 会自动计算出新的树与老树的节点差异，然后根据差异对 界面进行最小化重渲染;")]),t._v(" "),a("li",[t._v("在差异计算算法中，React     能够相对精确地知道哪些位置发生了改变以及应该如何改变，这 就保证了按需更新，而不是全部重新渲染。")])]),t._v(" "),a("h2",{attrs:{id:"_9、你怎么理解-redux-的-state-的-必会"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_9、你怎么理解-redux-的-state-的-必会"}},[t._v("#")]),t._v(" 9、你怎么理解 redux 的 state 的?(必会)")]),t._v(" "),a("p",[t._v("Store 对象包含所有数据。如果想得到某个时点的数据，就要对 Store 生成快照。这种时点的数 据集合，就叫做 State。 当前时刻的 State，可以通过 store.getState() 拿到。唯一改变 state 的方 法就是触发 action")]),t._v(" "),a("h2",{attrs:{id:"_10、除了在构造函数中绑定-this-还有其它方式吗-必会"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_10、除了在构造函数中绑定-this-还有其它方式吗-必会"}},[t._v("#")]),t._v(" 10、除了在构造函数中绑定 this，还有其它方式吗?(必会)")]),t._v(" "),a("p",[t._v("你可以使用属性初始值设定项(property initializers)来正确绑定回调，create-React-app 也是默 认支持的。在回调中你可以使用箭头函数，但问题是每次组件渲染时都会创建一个新的回调")]),t._v(" "),a("h2",{attrs:{id:"_11、-在构造函数中-调用-super-props-的目的是什么-必会"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_11、-在构造函数中-调用-super-props-的目的是什么-必会"}},[t._v("#")]),t._v(" 11、(在构造函数中)调用 super(props)的目的是什么?(必会)")]),t._v(" "),a("p",[t._v("在 super() 被调用之前，子类是不能使用 this 的，在 ES2015 中，子类必须在 constructor 中 调用 super()。传递 props 给 super() 的原因则是便于(在子类中)能在 constructor 访问 this.props")]),t._v(" "),a("h2",{attrs:{id:"_12、简述-flux-思想-必会"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_12、简述-flux-思想-必会"}},[t._v("#")]),t._v(" 12、简述 flux 思想?(必会)")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("用户访问 View")])]),t._v(" "),a("li",[a("p",[t._v("View 发出用户的     Action")])]),t._v(" "),a("li",[a("p",[t._v("Dispatcher 收到     Action,要求 Store 进行相应的更新")])]),t._v(" "),a("li",[a("p",[t._v('Store 更新后，发出一个"change"事件')])]),t._v(" "),a("li",[a("p",[t._v('View 收到"change"事件后，更新页面')])])]),t._v(" "),a("h2",{attrs:{id:"_13、事件在-react-中的处理方式-必会"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_13、事件在-react-中的处理方式-必会"}},[t._v("#")]),t._v(" 13、事件在 React 中的处理方式?(必会)")]),t._v(" "),a("p",[t._v("React 元素的事件处理和 DOM 元素类似。但是有一点语法上的不同")]),t._v(" "),a("p",[t._v("\\1. React 事件绑定属性的命名采用驼峰式写法，而不是小写。\n\\2. 如果采用 JSX 的语法你需要传入一个函数作为事件处理函数，而不是一个字符串(DOM 元素")]),t._v(" "),a("p",[t._v("的写法)")]),t._v(" "),a("h2",{attrs:{id:"_14、列出-redux-的核心方法-必会"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_14、列出-redux-的核心方法-必会"}},[t._v("#")]),t._v(" 14、列出 Redux 的核心方法?(必会)")]),t._v(" "),a("p",[t._v("\\1. Action – 这是一个用来描述发生了什么事情的对象 2. Reducer – 这是一个确定状态将如何变化的地方\n\\3. Store – 整个程序的状态/对象树保存在 Store 中\n\\4. View – 只显示 Store 提供的数据")]),t._v(" "),a("h2",{attrs:{id:"_15、-组件的-状态-state-和属性-props-之间有何不同-必会"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_15、-组件的-状态-state-和属性-props-之间有何不同-必会"}},[t._v("#")]),t._v(" 15、(组件的)状态(state)和属性(props)之间有何不同?(必会)")]),t._v(" "),a("p",[t._v("State 是一种数据结构，用于组件挂载时所需数据的默认值。State 可能会随着时间的推移而 发生突变，但多数时候是作为用户事件行为的结果。Props(properties 的简写)则是组件的配置。 props 由父组件传递给子组件，并且就子组件而言，props 是不可变的,组件不能改变自身的 props， 但是可以把其子组件的 props 放在一起(统一管理)")]),t._v(" "),a("h2",{attrs:{id:"_16、何为受控组件-controlledcomponent-必会"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_16、何为受控组件-controlledcomponent-必会"}},[t._v("#")]),t._v(" 16、何为受控组件(controlledcomponent) ?(必会)")]),t._v(" "),a("p",[t._v("在 HTML 中，类似 "),a("input"),t._v(","),a("textarea")])])}),[],!1,null,null,null);a.default=s.exports}}]);