(window.webpackJsonp=window.webpackJsonp||[]).push([[33],{303:function(a,e,p){"use strict";p.r(e);var r=p(13),_=Object(r.a)({},(function(){var a=this,e=a._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("h2",{attrs:{id:"_1、什么是-webpack-必会"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1、什么是-webpack-必会"}},[a._v("#")]),a._v(" 1、什么是 Webpack(必会)")]),a._v(" "),e("p",[a._v("1、基本定义\nWebpack 是一个打包模块化 javascript 的工具，在 Webpack 里一切文件皆模块，通过")]),a._v(" "),e("p",[a._v("loader 转换文件，通过 plugin 注入钩子，最后输出由多个模块组合成的文件，Webpack 专注构建 模块化项目，Webpack 可以看做是模块打包机:它做的事情是，分析你的项目结构，找到 JavaScript 模块以及其它的一些浏览器不能直接运行的拓展语言(Scss，TypeScript 等)，并将其打包为合适 的格式以供浏览器使用")]),a._v(" "),e("h2",{attrs:{id:"_2、webpack-的优点是什么-必会"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2、webpack-的优点是什么-必会"}},[a._v("#")]),a._v(" 2、Webpack 的优点是什么?(必会)")]),a._v(" "),e("p",[a._v("1、专注于处理模块化的项目，能做到开箱即用，一步到位 2、通过 plugin 扩展，完整好用又不失灵活 3、使用场景不局限于 web 开发")]),a._v(" "),e("p",[a._v("4、社区庞大活跃，经常引入紧跟时代发展的新特性，能为大多数场景找到已有的开源扩展 5、提供了更好的开发体验")]),a._v(" "),e("h2",{attrs:{id:"_3、webpack-的构建流程是什么-从读取配置到输出文件这个过程尽量-说全-必会"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3、webpack-的构建流程是什么-从读取配置到输出文件这个过程尽量-说全-必会"}},[a._v("#")]),a._v(" 3、Webpack 的构建流程是什么?从读取配置到输出文件这个过程尽量 说全(必会)")]),a._v(" "),e("p",[a._v("Webpack 的运行流程是一个串行的过程，从启动到结束会依次执行以下流程: 1、初始化参数:从配置文件和 Shell 语句中读取与合并参数，得出最终的参数 2、开始编译:用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对")]),a._v(" "),e("p",[a._v("象的 run 方法开始执行编译\n3、确定入口:根据配置中的 entry 找出所有的入口文件 4、编译模块:从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块")]),a._v(" "),e("p",[a._v("依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理 5、完成模块编译:在经过第 4 步使用 Loader 翻译完所有模块后，得到了每个模块被翻译")]),a._v(" "),e("p",[a._v("后的最终内容以及它们之间的依赖关系 6、输出资源:根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再")]),a._v(" "),e("p",[a._v("把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会 7、输出完成:在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入 到文件系统，在以上过程中，Webpack 会在特定的时间点广播出特定的事件，插件在监听到感兴 趣的事件后会执行特定的逻辑，并且插件可以调用 Webpack 提供的 API 改变 Webpack 的运行")]),a._v(" "),e("p",[a._v("结果")]),a._v(" "),e("h2",{attrs:{id:"_4、说一下-webpack-的热更新原理-必会"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4、说一下-webpack-的热更新原理-必会"}},[a._v("#")]),a._v(" 4、说一下 Webpack 的热更新原理(必会)")]),a._v(" "),e("p",[a._v("1、基本定义\nWebpack 的热更新又称热替换(Hot Module Replacement)，缩写为 HMR。这个机制可以")]),a._v(" "),e("p",[a._v("做到不用刷新浏览器而将新变更的模块替换掉旧的模块。 2、核心定义")]),a._v(" "),e("p",[a._v("2,1)HMR 的核心就是客户端从服务端拉去更新后的文件，准确的说是 chunk diff (chunk 需要更新的部分)，实际上 WDS 与浏览器之间维护了一个 websocket，当本地资源发生变化时， WDS 会向浏览器推送更新，并带上构建时的 hash，让客户端与上一次资源进行对比")]),a._v(" "),e("p",[a._v("2,2)客户端对比出差异后会向 WDS 发起 Ajax 请求来获取更改内容(文件列表、hash)， 这样客户端就可以再借助这些信息继续向 WDS 发起 jsonp 请求获取该 chunk 的增量更新")]),a._v(" "),e("p",[a._v("2,3)后续的部分(拿到增量更新之后如何处理?哪些状态该保留?哪些又需要更新?) 由 HotModulePlugin 来完成，提供了相关 API 以供开发者针对自身场景进行处理，像 react-hot-loader 和 vue-loader 都是借助这些 API 实现 HMR")]),a._v(" "),e("h2",{attrs:{id:"_5、webpack-与-grunt、gulp-的不同-必会"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_5、webpack-与-grunt、gulp-的不同-必会"}},[a._v("#")]),a._v(" 5、Webpack 与 grunt、gulp 的不同?(必会)")]),a._v(" "),e("p",[a._v("1、三者之间的区别\n三者都是前端构建工具，grunt 和 gulp 在早期比较流行，现在 Webpack 相对来说比较主")]),a._v(" "),e("p",[a._v("流，不过一些轻量化的任务还是会用 gulp 来处理，比如单独打包 CSS 文件等\n1,1)grunt 和 gulp 是基于任务和流(Task、Stream)的。类似 jQuery，找到一个(或一 类)文件，对其做一系列链式操作，更新流上的数据， 整条链式操作构成了一个任务，多个任")]),a._v(" "),e("p",[a._v("务就构成了整个 web 的构建流程。\n1,2)Webpack 是基于入口的。Webpack 会自动地递归解析入口所需要加载的所有资源")]),a._v(" "),e("p",[a._v("文件，然后用不同的 Loader 来处理不同的文件，用 Plugin 来扩展 Webpack 功能。 2、构建思路的区别")]),a._v(" "),e("p",[a._v("2,1)gulp 和 grunt 需要开发者将整个前端构建过程拆分成多个"),e("code",[a._v("Task")]),a._v("，并合理控制所有 "),e("code",[a._v("Task")]),a._v("的调用关系")]),a._v(" "),e("p",[a._v("2,2)Webpack 需要开发者找到入口，并需要清楚对于不同的资源应该使用什么 Loader 做何种解析和加工")]),a._v(" "),e("p",[a._v("3、 从知识背景区别\n3,1)gulp 更像后端开发者的思路，需要对于整个流程了如指掌 3,2)Webpack 更倾向于前端开发者的思路")]),a._v(" "),e("h2",{attrs:{id:"_6、有哪些常见的-loader-他们是解决什么问题的-必会"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_6、有哪些常见的-loader-他们是解决什么问题的-必会"}},[a._v("#")]),a._v(" 6、有哪些常见的 Loader?他们是解决什么问题的?(必会)")]),a._v(" "),e("p",[a._v("1、file-loader:把文件输出到一个文件夹中，在代码中通过相对 URL 去引用输出的文件")]),a._v(" "),e("p",[a._v("2、url-loader:和 file-loader 类似，但是能在文件很小的情况下以 base64 的方式把文件内 容注入到代码中去")]),a._v(" "),e("p",[a._v("3、source-map-loader:加载额外的 Source Map 文件，以方便断点调试 4、image-loader:加载并且压缩图片文件\n5、babel-loader:把 ES6 转换成 ES5\n6、css-loader:加载 CSS，支持模块化、压缩、文件导入等特性 7、style-loader:把 CSS 代码注入到 JavaScript 中，通过 DOM 操作去加载 CSS 8、eslint-loader:通过 ESLint 检查 JavaScript 代码")]),a._v(" "),e("h2",{attrs:{id:"_7、loader-和-plugin-的不同-必会"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_7、loader-和-plugin-的不同-必会"}},[a._v("#")]),a._v(" 7、Loader 和 Plugin 的不同?(必会)")]),a._v(" "),e("p",[a._v('1、不同的作用\n1,1)Loader 直译为"加载器"。Webpack 将一切文件视为模块，但是 Webpack 原生是只')]),a._v(" "),e("p",[a._v("能解析 js 文件，如果想将其他文件也打包的话，就会用到 loader。所以 Loader 的作用是让 Webpack 拥有了加载和解析非 JavaScript 文件的能力。")]),a._v(" "),e("p",[a._v('1,2)Plugin 直译为"插件"，Plugin 可以扩展 Webpack 的功能，让 Webpack 具有更多的 灵活性。 在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适 的时机通过 Webpack 提供的 API 改变输出结果')]),a._v(" "),e("p",[a._v("2、不同的用法\n2,1)Loader 在 module.rules 中配置，也就是说他作为模块的解析规则而存在。 类型为")]),a._v(" "),e("p",[a._v("数组，每一项都是一个 Object，里面描述了对于什么类型的文件(test)，使用什么加载(loader) 和使用的参数(options)")]),a._v(" "),e("p",[a._v("2,2)Plugin 在 plugins 中单独配置。 类型为数组，每一项是一个 plugin 的实例，参数 都通过构造函数传入")]),a._v(" "),e("h2",{attrs:{id:"_8、如何利用-webpack-来优化前端性能-高薪常问"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_8、如何利用-webpack-来优化前端性能-高薪常问"}},[a._v("#")]),a._v(" 8、如何利用 Webpack 来优化前端性能(高薪常问)")]),a._v(" "),e("p",[a._v("1、压缩代码。uglifyJsPlugin 压缩 js 代码， mini-css-extract-plugin 压缩 css 代码\n2、利用 CDN 加速，将引用的静态资源修改为 CDN 上对应的路径，可以利用 Webpack 对 于 output 参数和 loader 的 publicpath 参数来修改资源路径\n3、删除死代码(tree shaking)，css 需要使用 Purify-CSS\n4、提取公共代码。Webpack4 移除了 CommonsChunkPlugin (提取公共代码)，用 optimization.splitChunks 和 optimization.runtimeChunk 来代替")]),a._v(" "),e("h2",{attrs:{id:"_9、是否写过-loader-和-plugin-描述一下编写-loader-或-plugin-的思路-高薪常问"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_9、是否写过-loader-和-plugin-描述一下编写-loader-或-plugin-的思路-高薪常问"}},[a._v("#")]),a._v(" 9、是否写过 Loader 和 Plugin?描述一下编写 loader 或 plugin 的思路? (高薪常问)")]),a._v(" "),e("p",[a._v('1、基本定义\nLoader 像一个"翻译官"把读到的源文件内容转义成新的文件内容，并且每个 Loader 通')]),a._v(" "),e("p",[a._v("过链式操作，将源文件一步步翻译成想要的样子。 1、 编写思路")]),a._v(" "),e("p",[a._v('2.1)编写 Loader 时要遵循单一原则，每个 Loader 只做一种"转义"工作， 每个 Loader 的拿到的是源文件内容(source)，可以通过返回值的方式将处理后的内容输出，也可以调 用 this.callback()方法，将内容返回给 Webpack，还可以通过 this.async()生成一个 callback 函 数，再用这个 callback 将处理后的内容输出出去，此外 Webpack 还为开发者准备了开发 loader 的工具函数集——loader-utils')]),a._v(" "),e("p",[a._v("2.2)相对于 Loader 而言，Plugin 的编写就灵活了许多， Webpack 在运行的生命周期中 会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改 变输出结果\n2、 编写注意事项")]),a._v(" "),e("p",[a._v("3.1)Loader 支持链式调用，所以开发上需要严格遵循“单一职责”，每个 Loader 只负责自 己需要负责的事情\n3.2)Loader 运行在 node.js 中，我们可以调用任意 node.js 自带的 API 或者安装第三方模 块进行调用")]),a._v(" "),e("p",[a._v("3.3)Webpack 传给 Loader 的原内容都是 UTF-8 格式编码的字符串，当某些场景下 Loader 处理二进制文件时，需要通过 exports.raw = true 告诉 Webpack 该 Loader 是否需要 二进制数据")]),a._v(" "),e("p",[a._v("3.4)尽可能的异步化 Loader，如果计算量很小，同步也可以 3.5)Loader 是无状态的，我们不应该在 Loader 中保留状态 3.6)使用 loader-utils 和 schema-utils 为我们提供的实用工具 3.7)加载本地 Loader 方法")]),a._v(" "),e("h2",{attrs:{id:"_10、使用-webpack-开发时-你用过哪些可以提高效率的插件-高-薪常问"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_10、使用-webpack-开发时-你用过哪些可以提高效率的插件-高-薪常问"}},[a._v("#")]),a._v(" 10、使用 Webpack 开发时，你用过哪些可以提高效率的插件?(高 薪常问)")]),a._v(" "),e("p",[a._v("1、Webpack-dashboard:可以更友好的展示相关打包信息。 2、Webpack-merge:提取公共配置，减少重复配置代码 3、speed-measure-Webpack-plugin:简称 SMP，分析出 Webpack 打包过程中 Loader 和")]),a._v(" "),e("p",[a._v("Plugin 的耗时，有助于找到构建过程中的性能瓶颈 4、size-plugin:监控资源体积变化，尽早发现问题 5、HotModuleReplacementPlugin:模块热替换")]),a._v(" "),e("h2",{attrs:{id:"_11、什么是长缓存-在-webpack-中如何做到长缓存优化-高薪常-问"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_11、什么是长缓存-在-webpack-中如何做到长缓存优化-高薪常-问"}},[a._v("#")]),a._v(" 11、什么是长缓存?在 Webpack 中如何做到长缓存优化?(高薪常 问)")]),a._v(" "),e("p",[a._v("1、什么是长缓存 浏览器在用户访问页面的时候，为了加快加载速度，会对用户访问的静态资源进行存")]),a._v(" "),e("p",[a._v("储，但是每一次代码升级或者更新，都需要浏览器去下载新的代码，最方便和最简单的更新方式")]),a._v(" "),e("p",[a._v("就是引入新的文件名称 2、具体实现")]),a._v(" "),e("p",[a._v("在 Webpack 中，可以在 output 给出输出的文件制定 chunkhash，并且分离经常更新的代 码和框架代码，通过 NameModulesPlugin 或者 HashedModulesPlugin 使再次打包文件名不变")]),a._v(" "),e("h2",{attrs:{id:"_12、如何提高-webpack-的构建速度-高薪常问"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_12、如何提高-webpack-的构建速度-高薪常问"}},[a._v("#")]),a._v(" 12、如何提高 Webpack 的构建速度?(高薪常问)")]),a._v(" "),e("p",[a._v("在多入口情况下，使用 CommonsChunkPlugin 来提取公共代码\n1、通过 externals 配置来提取常用库\n2、利用 DllPlugin 和 DllReferencePlugin 预编译资源模块 通过 DllPlugin 来对那些我们引用但")]),a._v(" "),e("p",[a._v("是绝对不会修改的 npm 包来进行预编译，再通过 DllReferencePlugin 将预编译的模块加载进来。 3、使用 Happypack 实现多线程加速编译\n4、使用 Webpack-uglify-parallel 来提升 uglifyPlugin 的压缩速度。 原理上")]),a._v(" "),e("p",[a._v("Webpack-uglify-parallel 采用了多核并行压缩来提升压缩速度 5、使用 Tree-shaking 和 Scope Hoisting 来剔除多余代码")]),a._v(" "),e("h2",{attrs:{id:"_13、怎么实现-webpack-的按需加载-什么是神奇注释-高薪常问"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_13、怎么实现-webpack-的按需加载-什么是神奇注释-高薪常问"}},[a._v("#")]),a._v(" 13、怎么实现 Webpack 的按需加载?什么是神奇注释?(高薪常问)")]),a._v(" "),e("p",[a._v("1、按需加载\n在 Webpack 中，import 不仅仅是 ES6 module 的模块导入方式，还是一个类似 require 的")]),a._v(" "),e("p",[a._v("函数，我们可以通过 import('module')的方式引入一个模块，import()返回的是一个 Promise 对象; 使用 import()方式就可以实现 Webpack 的按需加载")]),a._v(" "),e("p",[a._v("2、神奇注释\n在 import()里可以添加一些注释，如定义该 chunk 的名称，要过滤的文件，指定引入")]),a._v(" "),e("p",[a._v("的文件等等，这类带有特殊功能的注释被称为神器注释")])])}),[],!1,null,null,null);e.default=_.exports}}]);